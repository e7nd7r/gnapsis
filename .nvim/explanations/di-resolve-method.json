{
  "tags": [
    "di",
    "dependency-injection",
    "rust",
    "gnapsis"
  ],
  "steps": [
    {
      "markers": [
        {
          "file": "src/mcp/server.rs",
          "end_line": 49,
          "start_line": 43,
          "highlight_type": "primary"
        }
      ],
      "content": "The `resolve` method is the entry point for dependency injection. It takes a type parameter `T` that must implement `FromRef<Context>`.\n\n```rust\npub fn resolve<T: FromRef<Context>>(&self) -> T {\n    T::from_ref(&self.ctx)\n}\n```\n\nWhen you call `self.resolve::<EntityRepository>()`, Rust:\n1. Looks up `EntityRepository::from_ref(&ctx)`\n2. Returns a fully constructed `EntityRepository`",
      "title": "The resolve<T> Method",
      "id": "resolve-method"
    },
    {
      "markers": [
        {
          "file": "src/di.rs",
          "end_line": 47,
          "start_line": 34,
          "highlight_type": "primary"
        }
      ],
      "content": "The `FromRef<T>` trait defines how to extract a value from a reference to `T`.\n\n```rust\npub trait FromRef<T> {\n    fn from_ref(input: &T) -> Self;\n}\n```\n\nThere's also a **blanket implementation** that says: any `Clone` type can be extracted from itself by cloning.\n\n```rust\nimpl<T: Clone> FromRef<T> for T {\n    fn from_ref(input: &T) -> Self {\n        input.clone()\n    }\n}\n```\n\nThis is key - it means `Arc<Graph>` can be extracted from `Arc<Graph>`.",
      "title": "The FromRef Trait",
      "id": "from-ref-trait"
    },
    {
      "markers": [
        {
          "file": "src/context.rs",
          "end_line": 27,
          "start_line": 14,
          "highlight_type": "primary"
        }
      ],
      "content": "The `Context` struct uses `#[derive(Context)]` which generates `FromRef<Context>` implementations for **each field type**.\n\nFor this Context with 3 fields:\n- `graph: Arc<Graph>`\n- `config: Arc<Config>`\n- `embedder: AppEmbedder`\n\nThe macro generates:\n```rust\nimpl FromRef<Context> for Arc<Graph> {\n    fn from_ref(ctx: &Context) -> Self {\n        ctx.graph.clone()\n    }\n}\nimpl FromRef<Context> for Arc<Config> { ... }\nimpl FromRef<Context> for AppEmbedder { ... }\n```",
      "title": "The #[derive(Context)] Macro",
      "id": "context-derive"
    },
    {
      "markers": [
        {
          "file": "src/repositories/entity.rs",
          "end_line": 17,
          "start_line": 13,
          "highlight_type": "primary"
        }
      ],
      "content": "Repositories and services use `#[derive(FromContext)]` which generates a `FromRef<Context>` implementation that **resolves each field recursively**.\n\nFor `EntityRepository` with field `graph: Arc<Graph>`:\n\n```rust\nimpl FromRef<Context> for EntityRepository {\n    fn from_ref(ctx: &Context) -> Self {\n        Self {\n            graph: <Arc<Graph> as FromRef<Context>>::from_ref(ctx)\n        }\n    }\n}\n```\n\nThis calls the `FromRef` impl generated by `#[derive(Context)]` on Context!",
      "title": "The #[derive(FromContext)] Macro",
      "id": "from-context-derive"
    },
    {
      "markers": [
        {
          "file": "src/services/embedding.rs",
          "end_line": 15,
          "start_line": 8,
          "highlight_type": "primary"
        }
      ],
      "content": "The `EmbeddingService` also uses `#[derive(FromContext)]`.\n\nWhen you call `self.resolve::<EmbeddingService>()`:\n\n1. Rust calls `EmbeddingService::from_ref(&ctx)`\n2. The generated impl resolves `embedder: AppEmbedder` by calling `AppEmbedder::from_ref(&ctx)`\n3. That returns `ctx.embedder.clone()` (from the Context derive)\n4. EmbeddingService is constructed with the cloned embedder\n\n**The entire chain is resolved at compile-time** - no runtime reflection!",
      "title": "EmbeddingService Resolution Chain",
      "id": "embedding-service"
    },
    {
      "markers": [],
      "content": "Here's how the DI resolution flows:\n\n```mermaid\ngraph TD\n    A[\"resolve&lt;EntityRepository&gt;()\"] --> B[\"EntityRepository::from_ref(&ctx)\"]\n    B --> C[\"Arc&lt;Graph&gt;::from_ref(&ctx)\"]\n    C --> D[\"ctx.graph.clone()\"]\n    D --> E[\"EntityRepository { graph }\"]\n    \n    F[\"resolve&lt;EmbeddingService&gt;()\"] --> G[\"EmbeddingService::from_ref(&ctx)\"]\n    G --> H[\"AppEmbedder::from_ref(&ctx)\"]\n    H --> I[\"ctx.embedder.clone()\"]\n    I --> J[\"EmbeddingService { embedder }\"]\n```\n\n**Key insight**: Everything resolves back to fields on Context. The macros just generate the boilerplate to wire it all together.",
      "title": "Complete Resolution Diagram",
      "id": "resolution-diagram"
    }
  ],
  "id": "di-resolve-method",
  "created": "2026-01-18T04:07:58Z",
  "title": "How the resolve<T> DI Method Works",
  "description": "Explains the compile-time dependency injection pattern used in Gnapsis via the resolve method."
}

