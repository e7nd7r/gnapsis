// Cypher Grammar for Pest
// Converted from openCypher ANTLR4 grammar
// Licensed under Apache License 2.0
//
// NOTE: This grammar relies on pest's implicit whitespace handling.
// The WHITESPACE rule is automatically inserted between elements of non-atomic rules.
// Explicit SP/SP? is only needed inside brackets/parens where implicit whitespace doesn't apply.

// =============================================================================
// Entry Point
// =============================================================================

Cypher = { SOI ~ Statement ~ ";"? ~ EOI }

Statement = { Query }

Query = { RegularQuery | StandaloneCall }

RegularQuery = { SingleQuery ~ Union* }

// Note: UNION ALL must come before UNION in PEG ordered choice
Union = {
    (UNION ~ ALL ~ SingleQuery)
    | (UNION ~ SingleQuery)
}

SingleQuery = { SinglePartQuery | MultiPartQuery }

SinglePartQuery = {
    (ReadingClause* ~ Return)
    | (ReadingClause* ~ UpdatingClause+ ~ Return?)
}

MultiPartQuery = {
    (ReadingClause* ~ UpdatingClause* ~ With)+ ~ SinglePartQuery
}

// =============================================================================
// Clauses
// =============================================================================

UpdatingClause = { Create | Merge | Delete | Set | Remove }

ReadingClause = { Match | Unwind | InQueryCall }

Match = { OPTIONAL? ~ MATCH ~ Pattern ~ Where? }

Unwind = { UNWIND ~ Expression ~ AS ~ Variable }

Merge = { MERGE ~ PatternPart ~ MergeAction* }

MergeAction = {
    (ON ~ MATCH ~ Set)
    | (ON ~ CREATE ~ Set)
}

Create = { CREATE ~ Pattern }

Set = { SET ~ SetItem ~ ("," ~ SetItem)* }

SetItem = {
    (PropertyExpression ~ "=" ~ Expression)
    | (Variable ~ "+=" ~ Expression)
    | (Variable ~ "=" ~ Expression)
    | (Variable ~ NodeLabels)
}

Delete = { DETACH? ~ DELETE ~ Expression ~ ("," ~ Expression)* }

Remove = { REMOVE ~ RemoveItem ~ ("," ~ RemoveItem)* }

RemoveItem = { (Variable ~ NodeLabels) | PropertyExpression }

InQueryCall = { CALL ~ ExplicitProcedureInvocation ~ (YIELD ~ YieldItems)? }

StandaloneCall = {
    CALL ~ (ExplicitProcedureInvocation | ImplicitProcedureInvocation) ~ (YIELD ~ YieldItems)?
}

YieldItems = { ("*" | (YieldItem ~ ("," ~ YieldItem)*)) ~ Where? }

YieldItem = { (ProcedureResultField ~ AS)? ~ Variable }

// =============================================================================
// WITH and RETURN
// =============================================================================

With = { WITH ~ ProjectionBody ~ Where? }

Return = { RETURN ~ ProjectionBody }

ProjectionBody = {
    DISTINCT? ~ ProjectionItems ~ Order? ~ Skip? ~ Limit?
}

ProjectionItems = {
    ("*" ~ ("," ~ ProjectionItem)*)
    | (ProjectionItem ~ ("," ~ ProjectionItem)*)
}

ProjectionItem = {
    (Expression ~ AS ~ Variable)
    | Expression
}

Order = { ORDER ~ BY ~ SortItem ~ ("," ~ SortItem)* }

Skip = { SKIP_KW ~ Expression }

Limit = { LIMIT ~ Expression }

SortItem = { Expression ~ (ASCENDING | ASC | DESCENDING | DESC)? }

Where = { WHERE ~ Expression }

// =============================================================================
// Patterns
// =============================================================================

Pattern = { PatternPart ~ ("," ~ PatternPart)* }

PatternPart = {
    (Variable ~ "=" ~ AnonymousPatternPart)
    | AnonymousPatternPart
}

AnonymousPatternPart = { PatternElement }

PatternElement = {
    (NodePattern ~ PatternElementChain*)
    | ("(" ~ PatternElement ~ ")")
}

// Inside parens/brackets we need explicit SP? since implicit whitespace doesn't apply
NodePattern = {
    "(" ~ SP? ~ (Variable ~ SP?)? ~ (NodeLabels ~ SP?)? ~ (Properties ~ SP?)? ~ ")"
}

PatternElementChain = { RelationshipPattern ~ NodePattern }

RelationshipPattern = {
    (LeftArrowHead ~ SP? ~ Dash ~ SP? ~ RelationshipDetail? ~ SP? ~ Dash ~ SP? ~ RightArrowHead)
    | (LeftArrowHead ~ SP? ~ Dash ~ SP? ~ RelationshipDetail? ~ SP? ~ Dash)
    | (Dash ~ SP? ~ RelationshipDetail? ~ SP? ~ Dash ~ SP? ~ RightArrowHead)
    | (Dash ~ SP? ~ RelationshipDetail? ~ SP? ~ Dash)
}

RelationshipDetail = {
    "[" ~ SP? ~ (Variable ~ SP?)? ~ (RelationshipTypes ~ SP?)? ~ RangeLiteral? ~ (Properties ~ SP?)? ~ "]"
}

Properties = { MapLiteral | Parameter }

RelationshipTypes = { ":" ~ SP? ~ RelTypeName ~ (SP? ~ "|" ~ ":"? ~ SP? ~ RelTypeName)* }

NodeLabels = { NodeLabel+ }

NodeLabel = { ":" ~ SP? ~ LabelName }

RangeLiteral = { "*" ~ SP? ~ (IntegerLiteral ~ SP?)? ~ (".." ~ SP? ~ (IntegerLiteral ~ SP?)?)? }

LabelName = { SchemaName }

RelTypeName = { SchemaName }

// =============================================================================
// Expressions
// =============================================================================

Expression = { OrExpression }

// Boolean operators - rely on implicit whitespace between keywords
OrExpression = { XorExpression ~ (OR ~ XorExpression)* }

XorExpression = { AndExpression ~ (XOR ~ AndExpression)* }

AndExpression = { NotExpression ~ (AND ~ NotExpression)* }

NotExpression = { NOT* ~ ComparisonExpression }

ComparisonExpression = { AddOrSubtractExpression ~ PartialComparisonExpression* }

AddOrSubtractExpression = {
    MultiplyDivideModuloExpression ~ (("+" ~ MultiplyDivideModuloExpression) | ("-" ~ MultiplyDivideModuloExpression))*
}

MultiplyDivideModuloExpression = {
    PowerOfExpression ~ (("*" ~ PowerOfExpression) | ("/" ~ PowerOfExpression) | ("%" ~ PowerOfExpression))*
}

PowerOfExpression = { UnaryAddOrSubtractExpression ~ ("^" ~ UnaryAddOrSubtractExpression)* }

UnaryAddOrSubtractExpression = { ("+"|"-")* ~ StringListNullOperatorExpression }

StringListNullOperatorExpression = {
    PropertyOrLabelsExpression ~ (StringOperatorExpression | ListOperatorExpression | NullOperatorExpression)*
}

// Inside brackets we need explicit SP?
ListOperatorExpression = {
    (IN ~ PropertyOrLabelsExpression)
    | ("[" ~ SP? ~ Expression ~ SP? ~ "]")
    | ("[" ~ SP? ~ Expression? ~ ".." ~ Expression? ~ SP? ~ "]")
}

StringOperatorExpression = {
    ((STARTS ~ WITH) | (ENDS ~ WITH) | CONTAINS) ~ PropertyOrLabelsExpression
}

NullOperatorExpression = {
    (IS ~ NULL_KW)
    | (IS ~ NOT ~ NULL_KW)
}

PropertyOrLabelsExpression = { Atom ~ PropertyLookup* ~ NodeLabels? }

Atom = {
    Literal
    | Parameter
    | CaseExpression
    | (COUNT ~ "(" ~ SP? ~ "*" ~ SP? ~ ")")
    | ListComprehension
    | PatternComprehension
    | (ALL ~ "(" ~ SP? ~ FilterExpression ~ SP? ~ ")")
    | (ANY_KW ~ "(" ~ SP? ~ FilterExpression ~ SP? ~ ")")
    | (NONE ~ "(" ~ SP? ~ FilterExpression ~ SP? ~ ")")
    | (SINGLE ~ "(" ~ SP? ~ FilterExpression ~ SP? ~ ")")
    | RelationshipsPattern
    | ParenthesizedExpression
    | FunctionInvocation
    | Variable
}

Literal = {
    NumberLiteral
    | StringLiteral
    | BooleanLiteral
    | NULL_KW
    | MapLiteral
    | ListLiteral
}

BooleanLiteral = { TRUE | FALSE }

ListLiteral = { "[" ~ SP? ~ (Expression ~ SP? ~ ("," ~ SP? ~ Expression ~ SP?)*)? ~ "]" }

PartialComparisonExpression = {
    ("=" ~ SP? ~ AddOrSubtractExpression)
    | ("<>" ~ SP? ~ AddOrSubtractExpression)
    | ("<" ~ SP? ~ AddOrSubtractExpression)
    | (">" ~ SP? ~ AddOrSubtractExpression)
    | ("<=" ~ SP? ~ AddOrSubtractExpression)
    | (">=" ~ SP? ~ AddOrSubtractExpression)
}

ParenthesizedExpression = { "(" ~ SP? ~ Expression ~ SP? ~ ")" }

RelationshipsPattern = { NodePattern ~ PatternElementChain+ }

FilterExpression = { IdInColl ~ Where? }

IdInColl = { Variable ~ IN ~ Expression }

FunctionInvocation = {
    FunctionName ~ "(" ~ SP? ~ DISTINCT? ~ (Expression ~ SP? ~ ("," ~ SP? ~ Expression ~ SP?)*)? ~ ")"
}

FunctionName = { (Namespace ~ SymbolicName) | EXISTS }

ExplicitProcedureInvocation = {
    ProcedureName ~ "(" ~ SP? ~ (Expression ~ SP? ~ ("," ~ SP? ~ Expression ~ SP?)*)? ~ ")"
}

ImplicitProcedureInvocation = { ProcedureName }

ProcedureResultField = { SymbolicName }

ProcedureName = { Namespace ~ SymbolicName }

Namespace = { (SymbolicName ~ ".")* }

ListComprehension = { "[" ~ SP? ~ FilterExpression ~ (SP? ~ "|" ~ SP? ~ Expression)? ~ SP? ~ "]" }

PatternComprehension = {
    "[" ~ SP? ~ (Variable ~ SP? ~ "=" ~ SP?)? ~ RelationshipsPattern ~ SP? ~ (WHERE ~ SP? ~ Expression ~ SP?)? ~ "|" ~ SP? ~ Expression ~ SP? ~ "]"
}

PropertyLookup = { "." ~ PropertyKeyName }

CaseExpression = {
    ((CASE ~ CaseAlternatives+) | (CASE ~ Expression ~ CaseAlternatives+)) ~ (ELSE ~ Expression)? ~ END
}

CaseAlternatives = { WHEN ~ Expression ~ THEN ~ Expression }

Variable = { SymbolicName }

// =============================================================================
// Literals
// =============================================================================

StringLiteral = @{
    ("\"" ~ (StringLiteral_double | EscapedChar)* ~ "\"")
    | ("'" ~ (StringLiteral_single | EscapedChar)* ~ "'")
}

StringLiteral_double = { (!("\"" | "\\") ~ ANY)+ }
StringLiteral_single = { (!("'" | "\\") ~ ANY)+ }

EscapedChar = @{
    "\\" ~ ("\\" | "'" | "\"" | "b" | "B" | "f" | "F" | "n" | "N" | "r" | "R" | "t" | "T" | UnicodeEscape)
}

UnicodeEscape = {
    ("u" | "U") ~ HexDigit ~ HexDigit ~ HexDigit ~ HexDigit ~ (HexDigit ~ HexDigit ~ HexDigit ~ HexDigit)?
}

NumberLiteral = { DoubleLiteral | IntegerLiteral }

MapLiteral = {
    "{" ~ SP? ~ (PropertyKeyName ~ SP? ~ ":" ~ SP? ~ Expression ~ SP? ~ ("," ~ SP? ~ PropertyKeyName ~ SP? ~ ":" ~ SP? ~ Expression ~ SP?)*)? ~ "}"
}

Parameter = { "$" ~ (SymbolicName | DecimalInteger) }

PropertyExpression = { Atom ~ (SP? ~ PropertyLookup)+ }

PropertyKeyName = { SchemaName }

IntegerLiteral = @{ HexInteger | OctalInteger | DecimalInteger }

HexInteger = @{ "0x" ~ HexDigit+ }

DecimalInteger = @{ "0" | (NonZeroDigit ~ Digit*) }

OctalInteger = @{ "0" ~ OctDigit+ }

HexDigit = { Digit | HexLetter }

HexLetter = { 'A'..'F' | 'a'..'f' }

Digit = { '0'..'9' }

NonZeroDigit = { '1'..'9' }

OctDigit = { '0'..'7' }

DoubleLiteral = @{ ExponentDecimalReal | RegularDecimalReal }

// Order matters: try longer matches first (with decimal point before integer-only)
ExponentDecimalReal = @{
    ((Digit+ ~ "." ~ Digit+) | ("." ~ Digit+) | Digit+) ~ ("E" | "e") ~ "-"? ~ Digit+
}

RegularDecimalReal = @{ Digit* ~ "." ~ Digit+ }

// =============================================================================
// Names and Identifiers
// =============================================================================

SchemaName = { SymbolicName | ReservedWord }

SymbolicName = @{
    UnescapedSymbolicName
    | EscapedSymbolicName
    | COUNT
    | FILTER
    | EXTRACT
    | ANY_KW
    | NONE
    | SINGLE
}

UnescapedSymbolicName = @{ IdentifierStart ~ IdentifierPart* }

IdentifierStart = { LETTER | "_" }

IdentifierPart = { LETTER | Digit | "_" }

LETTER = { 'A'..'Z' | 'a'..'z' | '\u{0080}'..'\u{FFFF}' }

EscapedSymbolicName = @{ ("`" ~ EscapedSymbolicName_inner* ~ "`")+ }

EscapedSymbolicName_inner = { !"`" ~ ANY }

// =============================================================================
// Keywords (case-insensitive)
// =============================================================================

ALL = @{ ^"all" ~ !IdentifierPart }
AND = @{ ^"and" ~ !IdentifierPart }
ANY_KW = @{ ^"any" ~ !IdentifierPart }
AS = @{ ^"as" ~ !IdentifierPart }
ASC = @{ ^"asc" ~ !IdentifierPart }
ASCENDING = @{ ^"ascending" ~ !IdentifierPart }
BY = @{ ^"by" ~ !IdentifierPart }
CALL = @{ ^"call" ~ !IdentifierPart }
CASE = @{ ^"case" ~ !IdentifierPart }
CONTAINS = @{ ^"contains" ~ !IdentifierPart }
COUNT = @{ ^"count" ~ !IdentifierPart }
CREATE = @{ ^"create" ~ !IdentifierPart }
DELETE = @{ ^"delete" ~ !IdentifierPart }
DESC = @{ ^"desc" ~ !IdentifierPart }
DESCENDING = @{ ^"descending" ~ !IdentifierPart }
DETACH = @{ ^"detach" ~ !IdentifierPart }
DISTINCT = @{ ^"distinct" ~ !IdentifierPart }
ELSE = @{ ^"else" ~ !IdentifierPart }
END = @{ ^"end" ~ !IdentifierPart }
ENDS = @{ ^"ends" ~ !IdentifierPart }
EXISTS = @{ ^"exists" ~ !IdentifierPart }
EXTRACT = @{ ^"extract" ~ !IdentifierPart }
FALSE = @{ ^"false" ~ !IdentifierPart }
FILTER = @{ ^"filter" ~ !IdentifierPart }
IN = @{ ^"in" ~ !IdentifierPart }
IS = @{ ^"is" ~ !IdentifierPart }
LIMIT = @{ ^"limit" ~ !IdentifierPart }
MATCH = @{ ^"match" ~ !IdentifierPart }
MERGE = @{ ^"merge" ~ !IdentifierPart }
NONE = @{ ^"none" ~ !IdentifierPart }
NOT = @{ ^"not" ~ !IdentifierPart }
NULL_KW = @{ ^"null" ~ !IdentifierPart }
ON = @{ ^"on" ~ !IdentifierPart }
OPTIONAL = @{ ^"optional" ~ !IdentifierPart }
OR = @{ ^"or" ~ !IdentifierPart }
ORDER = @{ ^"order" ~ !IdentifierPart }
REMOVE = @{ ^"remove" ~ !IdentifierPart }
RETURN = @{ ^"return" ~ !IdentifierPart }
SET = @{ ^"set" ~ !IdentifierPart }
SINGLE = @{ ^"single" ~ !IdentifierPart }
SKIP_KW = @{ ^"skip" ~ !IdentifierPart }
STARTS = @{ ^"starts" ~ !IdentifierPart }
THEN = @{ ^"then" ~ !IdentifierPart }
TRUE = @{ ^"true" ~ !IdentifierPart }
UNION = @{ ^"union" ~ !IdentifierPart }
UNWIND = @{ ^"unwind" ~ !IdentifierPart }
WHEN = @{ ^"when" ~ !IdentifierPart }
WHERE = @{ ^"where" ~ !IdentifierPart }
WITH = @{ ^"with" ~ !IdentifierPart }
XOR = @{ ^"xor" ~ !IdentifierPart }
YIELD = @{ ^"yield" ~ !IdentifierPart }

// Reserved words that can be used as identifiers in some contexts
ReservedWord = {
    ALL | ASC | ASCENDING | BY | CREATE | DELETE | DESC | DESCENDING
    | DETACH | EXISTS | LIMIT | MATCH | MERGE | ON | OPTIONAL | ORDER
    | REMOVE | RETURN | SET | SKIP_KW | WHERE | WITH | UNION | UNWIND
    | AND | AS | CONTAINS | DISTINCT | ENDS | IN | IS | NOT | OR
    | STARTS | XOR | FALSE | TRUE | NULL_KW | CASE | WHEN | THEN | ELSE | END
}

// =============================================================================
// Symbols
// =============================================================================

LeftArrowHead = { "<" | "\u{27e8}" | "\u{3008}" | "\u{fe64}" | "\u{ff1c}" }

RightArrowHead = { ">" | "\u{27e9}" | "\u{3009}" | "\u{fe65}" | "\u{ff1e}" }

Dash = {
    "-" | "\u{00ad}" | "\u{2010}" | "\u{2011}" | "\u{2012}" | "\u{2013}"
    | "\u{2014}" | "\u{2015}" | "\u{2212}" | "\u{fe58}" | "\u{fe63}" | "\u{ff0d}"
}

// =============================================================================
// Whitespace and Comments
// =============================================================================

// SP is for explicit whitespace inside brackets/parens where implicit doesn't apply
SP = _{ (WHITESPACE | COMMENT)+ }

// WHITESPACE is special in pest - automatically inserted between non-atomic rule elements
WHITESPACE = _{ " " | "\t" | "\n" | "\r" | "\u{000B}" | "\u{000C}" | "\u{00A0}" | "\u{1680}"
    | "\u{2000}" | "\u{2001}" | "\u{2002}" | "\u{2003}" | "\u{2004}" | "\u{2005}"
    | "\u{2006}" | "\u{2007}" | "\u{2008}" | "\u{2009}" | "\u{200A}" | "\u{2028}"
    | "\u{2029}" | "\u{202F}" | "\u{205F}" | "\u{3000}" }

// COMMENT is special in pest - automatically inserted between non-atomic rule elements (like WHITESPACE)
COMMENT = _{
    ("/*" ~ (!"*/" ~ ANY)* ~ "*/")
    | ("//" ~ (!NEWLINE ~ ANY)*)
}

NEWLINE = _{ "\n" | "\r\n" | "\r" }
